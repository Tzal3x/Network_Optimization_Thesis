function results = heuristic_1(DISTANCE_MATRIX_CA, nodes, XIJ_CA, LINK_CAPACITY, NUMBER_OF_SATELLITES, BUFFER_BOUND, GREEDY_CRITERION)
% Definition: heuristic_1(DISTANCE_MATRIX_CA, INF_TR_VECTOR, NODES, XIJ_CA, CAPACITY_BOUNDS, COMMUNICATION_RANGE)
%  Heuristic (greedy-like) algorithm that aims to approximately solve the satellite-station DTNUM
%  problem. i.e. the same we were trying to solve at 'solve_part2.m'
%  The Algorithm: --------------------------------------------------------
%  The algorithm contains epochs and epochs contain rounds.
%  An epoch is a single time unit that is followed by the corresponding
%  topology (a graph).
%  A round contains the below steps:
%  1) For every node, find the neighbor that is nearest
%  to a station.
%  2) Send it as much information as possible, then do the same to the second
%  nearest neighbor to a station until there can be no further information
%  transferred. 
%  3) Repeat until no node can transfer any data.
%  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%  DISTANCE_MATRIX_CA = cell array of distance matrixes. each element is the
%  distance matrix of a given epoch.
% 
%  <not included!> INF_TR_VECTOR = (Information Transmission Vector) information that is generated by each node and is needed to be transmitted. 
%
%  nodes = vector of <node> objects.
%
%  XIJ_CA = cell arrayof cell arrays, each element contains a link's info about it's two
%  ends (reffered to as parents)
%
%  LINK_CAPACITY = vector containing the capacity bounds of links
%
%  COMMUNICATION_RANGE = the maximum distance between nodes that a
%  connection can be established
%
%  BUFFER_BOUND = the upper limit of buffer values
%
%  GREEDY_CRITERION = 'closest'/'fastest'. 'closest' is the satellite that
%  is closest to a station and 'fastest corresponds to the satellite that
%  moves faster to the direction of a station

%     disp('=======================================================================================================================================')
%     disp(' >>> Inside heuristic_1_'+GREEDY_CRITERION+'!!! ==========================================================================================================')    
%     disp('=======================================================================================================================================')
    n = length(nodes);
    NUMBER_OF_STATIONS = n - NUMBER_OF_SATELLITES; 
    total_epochs = length(DISTANCE_MATRIX_CA); % get total epochs
    GENERATED_INFO = 10;
    % Results (each epochs results are an element of each cell array):
    flows_results_ca = {}; % contains each epoch's LINK_RATES_VECTOR
    buffer_results_ca = {};
    tic
    for epoch = 1:total_epochs % for every epoch
        disp('---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------')
        disp('---- E P O C H '+ string(epoch) + ' --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------')
        disp('---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------')
        current_distance_matrix = DISTANCE_MATRIX_CA{epoch}; % get distances between nodes
        
        current_xij = XIJ_CA{epoch}; % get current xij cell array
         %{
         Creating new xij vector. {1}[ 1 | 1 | 2 ]    [12;  
                                  {2}[ 1 | 2 | 4 ] to  24]
         Cell array to vector were 12 (twelve) means parent1=1 parent2=2.
         %}
        new_xij = null(1,1); % e.g. [12    16    23    26    34    21    32    43]
        links = null(1,1); % holds same info as new_xij but in another format: e.g. [1  2; 1  6; 2  3; 2  6; 3  4; 2  1; 3  2; 4  3]
        unwanted = null(1,1); % deleting station to satellite links
        total_links = length(current_xij);
        
        buffer_results_ca{epoch} = zeros(1,n); % used to debug the NO-LINKS-IN-EPOCH problem
        for i = 1:(2*total_links)
            if i <= total_links
                new_xij = [new_xij, str2double(string(current_xij{i}(2))+string(current_xij{i}(3)))];
                links = [links; current_xij{i}(2), current_xij{i}(3)];
            elseif i > total_links
                ii = i - total_links;
                if current_xij{ii}(3) > NUMBER_OF_SATELLITES
                    unwanted = [unwanted, i];
                end
                new_xij = [new_xij, str2double(string(current_xij{ii}(3))+string(current_xij{ii}(2)))];
            end
        end
        new_xij(unwanted) = [];


        % if there are no links:
        if isempty(links) 
           % Dwse values sta main role vetors kai meta continue stin epomeni epoch
           link_rates_vector = null(1,1);
           divergence_results = zeros(1,n); % 0 divergence for all nodes
           if epoch > 1
              buffer_results_ca{epoch} = buffer_results_ca{epoch-1}; % maintain previous buffers
           else
              buffer_results_ca{epoch} =  zeros(1,n); % 0 divergence for all nodes
           end
           flows_results_ca{epoch} = [link_rates_vector, divergence_results, buffer_results_ca{epoch}];
           continue
        end
        links = [links; [links(:,2), links(:,1)]];
        links(unwanted,:) = [];


        
        % Create the equivalent of A matrix (inequality constraints per link)
        num_links = length(links(:,1));
        A = null(1); % (!)
        for link1 = 1:num_links % for every link
            par_1 = links(link1,1);
            par_2 = links(link1,2);
            temp_Rd_vector = zeros(1, num_links); % each row corresponds to a part of A matrix row.
            for link2 = 1:num_links % iterate every other link and pick it if...
               temp_par_1 = links(link2,1);
               temp_par_2 = links(link2,2);
               if (temp_par_1 == par_1) || (temp_par_1 == par_2) || (temp_par_2 == par_1) || (temp_par_2 == par_2)
                  temp_Rd_vector(link2) = (LINK_CAPACITY - 0.5 * log( current_distance_matrix(temp_par_1, temp_par_2) ))^(-1); % R(d)^(-1)
               end
            end
            A = [A; temp_Rd_vector];
        end
        
%         disp("A:");disp(A.^(-1)); % debug
        
        % These vectors play main roles:
        num_station_links = get_nstat_links(XIJ_CA{epoch}, NUMBER_OF_SATELLITES); % get number of satellite-to-station links
        INF_TR_VECTOR = [GENERATED_INFO * ones(1,NUMBER_OF_SATELLITES), zeros(1,NUMBER_OF_STATIONS)]; % creating ITV: [10,10,...,10, 0,...,0] 
        if epoch > 1
            previous_buffer = buffer_results_ca{epoch-1};
            for iter = 1:n 
                exceeds = (GENERATED_INFO + previous_buffer(iter)) >= BUFFER_BOUND; % boolean
                if exceeds % IF previous buffers plus generated info exceed buffer bounds...
                    INF_TR_VECTOR(iter) = BUFFER_BOUND;
                else
                    INF_TR_VECTOR(iter) = GENERATED_INFO + previous_buffer(iter); % add remaining info of previous epoch to current
                end
            end
        end
        INF_TR_VECTOR_START = INF_TR_VECTOR; % INF_TR_VECTOR at the start of the epoch
        link_rates_vector = zeros(1,length(XIJ_CA{epoch})*2-num_station_links); % similar to optimal flows
        
        disp("-------------------------------------------------")
        disp("Main vectors at the start of the epoch:")
        disp("INF_TR_VECTOR_START:");disp(INF_TR_VECTOR_START); % debug
        disp("link_rates_vector:");disp(link_rates_vector); % debug
        if epoch > 1
            disp("buffer_results_ca:");disp(buffer_results_ca{epoch-1}); % previous buffs % debug
        end
        disp("-------------------------------------------------")
        
        sat_to_stat_matrix = null(3,NUMBER_OF_SATELLITES);% 3xNUMBER_OF_SATELLITES (dimensions) matrix containing the distance to the closest station of each satellite
        for node = 1:NUMBER_OF_SATELLITES
            if strcmp(GREEDY_CRITERION, 'closest')
                to_station_dist = min(current_distance_matrix(node,(NUMBER_OF_SATELLITES+1):length(nodes))); % find minimum distance between stations and other_node
                closest_station = find(current_distance_matrix(node,:) == to_station_dist); % CRITERION 1, FIND CLOSEST STATION
                sat_to_stat_matrix(1,node) = node;
                sat_to_stat_matrix(2,node) = closest_station;  
                sat_to_stat_matrix(3,node) = to_station_dist;
            elseif strcmp(GREEDY_CRITERION, 'fastest')
                if epoch > 1
                    speed_matrix = DISTANCE_MATRIX_CA{epoch-1} - DISTANCE_MATRIX_CA{epoch};
%                     disp('PREVIOUS DISTANCE MATRIX:');disp(DISTANCE_MATRIX_CA{epoch-1}); % debug
                else
                    speed_matrix = 0 - DISTANCE_MATRIX_CA{epoch}; % an na vrethei to -max = min twn apostasewn. alliws tha epelege th megalyterh apostash
                end
                    satel_to_station_speeds = speed_matrix(node,(NUMBER_OF_SATELLITES+1):length(nodes));
                    max_speed_to_station = max(satel_to_station_speeds); % me poia taxythta kateuthinetai grigorotera pros tous stathmous
                    which_station = find(speed_matrix(node,:) == max_speed_to_station); % se POION STATHMO katefthinetai pio grigora
                    sat_to_stat_matrix(1,node) = node;
                    sat_to_stat_matrix(2,node) = which_station;  
                    sat_to_stat_matrix(3,node) = max_speed_to_station;
            end
        end   

        % "Neighbor" closest to station *increasing order*: (Could be a self, or the closest could not be a neighbor)
        if strcmp(GREEDY_CRITERION, 'closest')
            ordered_sat_to_stat =  sortrows(sat_to_stat_matrix',3)';% a little shady, MIGHT WANT TO INVESTIGATE WHILE DEBUGGING
        elseif strcmp(GREEDY_CRITERION, 'fastest')
            ordered_sat_to_stat =  -sortrows(-sat_to_stat_matrix',3)'; % decreasing order! The fastest should be first in row!
        end
        
%         disp("sat_to_stat_matrix:");disp(sat_to_stat_matrix);
%         disp("ordered_sat_to_stat:");disp(ordered_sat_to_stat);
        
        %{
         If minimum is a neighbor or self (a connection can be
         established) then use the link connecting current node and
         neighbor:
        %}
        next_round_bool = true;
        round = 0;
        forbidden_links = null(1,1); % here are registered links that have already been used
%         disp("Entering algorithm rounds:\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/")
        while(next_round_bool) % Rounds of algorithm start here
            next_round_bool = false; % if no more info can be transferred it will remain <false> and algorithm will terminate
            round = round + 1;
%             disp('> round '+string(round)+': +++++++++++++++++++++++++++++++++++++')
            for sat = 1:NUMBER_OF_SATELLITES
                % Checking first if self is connected with a station:
                temp_osts = ordered_sat_to_stat(1:2,:); % temp_osts: temporary ordered_sat_to_stat
                temp2 = ordered_sat_to_stat(1,:) == sat; % delete that column to avoid duplicates
                temp_osts(:,temp2) = [];
                
                for k = (NUMBER_OF_SATELLITES+NUMBER_OF_STATIONS):-1:(NUMBER_OF_SATELLITES+1) % adding sat to every station pseudo-links
                    temp_osts = [[sat; k] ,temp_osts];
                end
%                 disp(">> Changing sat: +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
%                 disp("temp_osts:");disp(temp_osts); % DEBUG
%                 disp("________________________________ S T E PS ________________________________")
                for i = 1:length(temp_osts(1,:)) % checking for neighbors                    
                    sat2 = temp_osts(1,i); % candidate                    
                    if sat == sat2 % this means that sat is close to a station and therefore he transmits the info directly
                        sat2 = temp_osts(2,i); % sat2 becomes the target station, else sat would transmit to itself
                    end
                    str2num_link = str2double(string(sat)+string(sat2)); % using this to spot which link will be used
                    which_link = find(new_xij == str2num_link);
                    
%                     disp("Investigating sat, sat2: "+string(sat)+", "+string(sat2));
                    
                    if ~isempty(which_link)  % if they are neighbors there exists at least one conneting them
%                         disp("- neighbors!")
                        which_link = which_link(1); %to avoid duplicates, get unique
                        if (INF_TR_VECTOR(sat) > 0)  & isempty(find(forbidden_links == str2num_link)) %#ok<AND2,EFIND> % IF INFO CAN BE TRANSMITTED
                            
                            disp(string(sat)+"->"+string(sat2)) % DEBUG
                            
                            % Construct optimization problem:  
                            f = -1;
                            
                            Atemp2 = A;
                            disp("Constructing optimization problem parameters  $_$_$_$_$_$_$_$_$_$_$_$_$_$_$_$_$_$_$_$_$")
                            disp("Atemp2:");disp(Atemp2);
                            ub2 = Atemp2(:,which_link); % get which link coefs
                            
                            disp("ub2:");disp(ub2);
                            Atemp2(:,which_link) = []; % delete column
                            disp("Atemp2:");disp(Atemp2);
                            temp_link_rates_vector = link_rates_vector;                            
                            disp("temp_link_rates_vector");disp(temp_link_rates_vector);
                            temp_link_rates_vector(which_link) = [];
                            disp("temp_link_rates_vector");disp(temp_link_rates_vector);
                            Atemp2 = Atemp2 * temp_link_rates_vector';
                            disp("Atemp2 = Atemp2 * temp_link_rates_vector'");disp(Atemp2)
                            lb = 0;
                            
                            disp("Removing zero values of ub2 and the corresponding of Atemp2...")
                            zeroes_ub2 = find(ub2==0); % if I skip this step, division by zero occurs (inf values)
                            if ~isempty(zeroes_ub2)
                               ub2(zeroes_ub2) = []; % remove zero values   
                               Atemp2(zeroes_ub2) = [];
                            end
                                                        
                            ub = min((ub2.^(-1)).*(1-Atemp2));%,LINK_CAPACITY, INF_TR_VECTOR(sat)]); %#ok<NBRAK>
                            disp("(ub2.^(-1)).*(1-Atemp2):");disp((ub2.^(-1)).*(1-Atemp2));
                            
                            disp("lb:");disp(lb);
                            disp("ub:");disp(ub);
                            
                            options = optimoptions('linprog','Display','none');% In order to get more speed (avoid "optimal solution found" reports
                            info_transmitted = linprog(f,[],[],[],[],lb,ub,options); % info that can be transmitted according to the inequality constraints of the link
                            
                            if isempty(info_transmitted) % if there isnt a solution found
                               disp("[Report:] info_transmitted is null")
                               break
                            end
                            
                            % If upper bound of link is reached, do not transmit any more info:
                            if info_transmitted >= link_rates_vector(which_link) 
                                info_transmitted = info_transmitted - link_rates_vector(which_link);
%                                 break
                            end
                            
                            % If the requested info to be transmitted exceeds the available info, send all the available
                            if info_transmitted >= INF_TR_VECTOR(sat)
                               info_transmitted = INF_TR_VECTOR(sat);
                            end
                               
                            if info_transmitted > 0.1
                                % Registering used link:
                                link2 = str2double(string(sat2) + string(sat)); % opposite direction (because if one link is used, the other should be silent
                                forbidden_links = [forbidden_links, link2];
                                next_round_bool = true;
                            else
                                disp("[Report:] info_transmitted is 0")
                                continue
                            end
                                                       
                            % Check buffer bound:
                            if epoch > 1  % Remember that if sat2 is a station, there is no buffer and therefore no constraint can get violated
                                if  (sat2 < NUMBER_OF_SATELLITES) && (buffer_results_ca{epoch-1}(sat2) + info_transmitted > BUFFER_BOUND) % If previous buffer plus the incoming information exceeds buffer bound then cancel transmission
                                    disp("Buffer bound exceeded! Returning information back to transmitter")
                                    next_round_bool = false;
                                    continue
                                end
                            end
                            
                            % Update:
                            INF_TR_VECTOR(sat) = INF_TR_VECTOR(sat) - info_transmitted;
                            INF_TR_VECTOR(sat2) = INF_TR_VECTOR(sat2) + info_transmitted;
                            link_rates_vector(which_link) = link_rates_vector(which_link) + info_transmitted;

                            disp("info_transmitted");disp(info_transmitted) % debug
                            disp("INF_TR_VECTOR:");disp(INF_TR_VECTOR) % debug
                            disp("link_rates_vector");disp(link_rates_vector) % debug
                            disp("PAUSED . . . . . . . . . . . . .");pause % debug   
                           
                            % Feasibility checks:
                            tyropita = A*link_rates_vector';
                            if sum(tyropita > 1) ~= 0 % if there is an inequality constraint vil
                                disp("[~Error] At epoch "+string(epoch)+", round "+string(round)+": violated "+ string(sum(tyropita > 1))+" ineq. constraints.");
                                disp(string(sat)+"->"+string(sat2)) % DEBUG
                            end
                       elseif INF_TR_VECTOR(sat) == 0 % Outs of info
%                            disp("No info can be transmitted...")
                             break; % if there is no remaining info o obe transmitted for now, then move to next satellite
                       elseif ~isempty(find(forbidden_links == str2num_link)) %#ok<EFIND>
%                            disp("Forbidden link! Already used its opposite: "+string(sat2)+string(sat))
                       end % end if info can be transferred
                    else
%                        disp("- NOT neighbors")
                   end % end if neighbors
               end % end for closest to stations nodes
           end % end for every satellite
        end % end of rounds 
%         disp('> End of epoch results:')
%         disp('INF_TR_VECTOR:'); disp(INF_TR_VECTOR);
%         disp('link_rates_vector:'); disp(link_rates_vector);
        
        buffer_results_ca{epoch} = [INF_TR_VECTOR(1:(length(INF_TR_VECTOR)-NUMBER_OF_STATIONS)), zeros(1,NUMBER_OF_STATIONS)]; % PETAW OTI INFO PERISSEPSE TWN STATIONS
        previous_buffer = 0;
        if epoch > 1
            previous_buffer = buffer_results_ca{epoch-1};
        end
        divergence_results =  INF_TR_VECTOR_START - INF_TR_VECTOR + buffer_results_ca{epoch} - previous_buffer; % DIVERGENCE VERSION 3, apla elysa ws pros to divergence doulevwntas panw sth gnwsth isothta
        flows_results_ca{epoch} = [link_rates_vector, divergence_results, buffer_results_ca{epoch}]; 
    end % end of epochs

    
    final = null(1,1);
    for i = 1:length(flows_results_ca)
        final = [final, flows_results_ca{i}];
    end
    
    results_ca{1} = final; % final result
    results_ca{2} = toc; % time performance
    results = results_ca ;
end